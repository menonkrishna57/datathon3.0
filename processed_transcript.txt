what's the first thing you should do when your code throws an error?
obviously, you should change nothing and try to run it again a few times.
if that doesn't work, you're gonna need a computer science degree.
the awesome thing about software engineering is that you can learn to code and get a high paying job while literally having no idea how anything actually works.
it all just feels like magic, like a pilot driving a giant metal tube in the sky while knowing nothing about aerodynamics.
mother of god, no.
oh, shit.
welcome to computer science 101.
in today's video, you'll learn the science behind the garbage code you've been writing by learning 101 different computer computer science terms and concepts.
this is a computer.
it's just a piece of tape that holds ones and zeros along with a device that can read and write to it.
it's called a turing machine, and in theory, it can compute anything, like the graphics in this video or the algorithm that recommended that you watch it.
at the core of modern computers, we have the central processing unit.
if we crack it open, we find a piece of silicon that contains billions of tiny transistors, which are like microscopic on off switches.
the value at one of these switches is called a bit and is the smallest piece of information a computer can use.
however, one bit by itself is not very useful.
so they come in a package of eight called a byte.
one byte can represent 256 different values, like all the characters that you type on your keyboard.
in fact, when you type into your keyboard, the character produced is actually mapped to a binary value in a character encoding like ascii or utf8.
binary is just a system for counting, like the base 10 system you normally use when counting on your fingers.
but it only has two characters, 1 and 0.
humans have a hard time reading binary, so most often it's represented in a hexadecimal base 16 format.
10 numbers and 6 letters can represent a 4 bit group called a nibble.
as a developer, when you write code in a programming language, it will eventually be converted into machine code, which is a binary format that can be decoded and executed by the cpu.
what it doesn't do, though, is store data for your applications.
for that, computers have random access memory, or ram.
it's like a neighborhood, and inside of every house lives a byte.
every location has a memory address which the cpu can read and write to.
you can think of the cpu and ram as the brain of the computer.
but in order for a computer to be useful, it needs to handle, handle, input, and output.
an input device might be the keyboard and mouse, while an output device might be your monitor.
luckily, most developers don't need to worry about how this hardware fits together, because we have operating system kernels like linux, mac and windows that control all hardware resources via device drivers.
now to start hacking on the operating system.
your first entry point is the shell, which is a program that exposes the operating system to the end user.
it's called a shell because it wraps the kernel.
it takes a line of text as input and produces an output.
this is called a command line interface.
not only can it connect to your own comp, but with the secure shell protocol, it can also connect to remote computers over a network.
now that you have access to the mainframe, it's time to pick a programming language which is a tool that uses the abstraction principle to make computers practical to work with for humans.
by simplifying different systems layer by layer.
some languages like python are interpreted.
that means there's a program called an interpreter that will execute each line of code one by one.
other languages like c are compiled.
they use a compiler to convert the entire program into machine code in advance before the cpu attempts to execut it.
this results in an executable file that can be run by the operating system without any extra dependencies.
now, every programming language has a variety of built in data types to represent the data we're working with in our code.
instead of bytes, we work with more human friendly things like characters and numbers.
now, the most fundamental way to use data in your application is to declare a variable.
this attaches a name to a data point, allowing you to reuse it somewhere else in your code.
python is a dynamically typed language, which means we don't need to tell the program exactly which data type is assigned to a variable, it just figures it out automatically.
however, other languages like c are statically typed, and that means you need to specify the data type of a variable in your code.
when you define a variable, its value is stored somewhere in memory on the hardware and you may need to allocate and free up memory throughout the program.
a pointer is a variable whose value is the memory address of another variable, which can be used for low level memory control.
many languages don't want to deal with low level memory management and instead implement a garbage collector which automatically allocates and deallocates memory when an object is no longer referenced in the program.
garbage day, huh?
no.
now, the data types available are different in every programming language, but typically you'll find int to represent whole numbers which may or may not be signed or unsigned to represent negative numbers as well.
when numbers require a decimal point, they typically use the floating point type.
it's called a float because there's only enough memory to represent a certain range of numbers at a certain precision, and is basically a form of scientific notation to make computers faster.
if you need more range or precision, many languages also have a double that doubles the amount of memory used for the number.
now, when it comes to characters, you'll typically find the char data type to represent a single character, or more commonly, a string to represent multiple characters together.
ultimately, these characters get stored in a memory address somewhere, but they need to be stored in a certain order.
when the order starts with the most significant byte and the smallest memory address, it's called big endian, or vice versa.
if the least significant byte is stored in the smallest address, it's called little endian.
when it comes to practical software engineering, one of the most fundamental things we do is organize data into data data structures.
the most useful data structure is probably the array or list.
just like a shopping list, it organizes multiple data points in order.
however, it also maintains an index of integers that starts at zero and goes up for every new item in the list.
that can be useful, but you don't actually need an index to create a list of items.
another option is a linked list where each item has a pointer to the next item in front of it.
another option is a stack that follows the last in, first out principle.
it's like stacking a set of plates.
then when you want to access the data, you pop the last one off the top.
the inverse option is a queue, which is first in, first out.
just like when you get into the breadline, the first person there is the first one to be fed.
now, another extremely useful data structure is the hash, which might also be called a map or dictionary.
it's like an array, but instead of an index of integers, you define the keys that point to each individual item, giving you a collection of key value pairs.
in many cases, though, it's not efficient to organize data in a linear way.
to address that problem, we have trees, which organize nodes together in a hierarchy that can often be traversed more quickly.
this can sometimes be too rigid of a data structure, though, so instead a graph can be created to connect multiple nodes together in a virtually unlimited number of ways.
a graph has a node for the data and an edge for the relationship between the data points.
data structures are essential, but they don't do anything by themselves.
to do something useful, you'll need to code up an algorithm which is just code that solves a problem.
i took the initiative in creating the internet.
in our code we have several mechanisms for implementing algorithms, the most fundamental of which is a function, which is a block of code that takes an input, then does something and returns returns an output.
like a variable, a function has a name and it can be called from other parts of your code with different input parameters called arguments.
one thing you might do in the function body is compare one value to another.
every language has a variety of built in operators like equality, greater than and less than that you can use to compare two values.
if a is greater than b, then it forms a value of true.
but if b is greater than a, then the value is false.
true false is what's known as a boolean data type.
and whenever your code produces a value like this, it's known as an expression.
but not all code will produce a value.
sometimes your code will simply do something which is known as a statement.
a good example is the if statement which handles conditional logic.
for example, if the condition is true, it will execute this code.
otherwise it will short circuit and run the code inside of the else block.
another very common type of statement is a loop.
a while loop will run this block of code over and over again until the condition in the parentheses becomes false.
that can be useful, but more often than not, you'll want to loop over an iterable data type like an array.
most languages have a for loop that can run some code for every object in the arr or iterable data structure.
now, in some cases, a function may not have an output, which is generally called a void function.
an interesting thing about functions is that they can call themselves.
when a function calls itself, it's called recursion, because when done like this, by default it will recurse forever, creating an infinite loop.
that happens because when you call a function, the programming language will put it into memory on what's known as the call stack, which is a short term chunk of memory for executing your code.
when a function keeps calling itself, the language will keep pushing frames onto the call stack until you get a stack overflow error.
to avoid this, your algorithm needs a base condition so it knows when to terminate the loop.
now, when you write an algorithm, you'll need to determine if it's any good.
and the system for doing that is called big o notation.
it's a standard format for approximating the performance of an algorithm at scale.
it may reference time complexity, which is how fast your algorithm will run, and space complexity which deals with how much memory is required to run it.
developers have many different algorithm types at their disposal.
the most crude option is brute force, where you might loop over every possible combination to hack somebody's credit card pin.
a more sophisticated approach might be divide and conquer, like binary search, where you cut the problem in half multiple times until you find what you're looking for.
another option is dynamic programming algorithms, where a problem is broken down into multiple smaller subproblems and the result of each computation is stored for later use using a technique called memoization.
that means if a function has already been called, it will use the existing value instead of recomputing it again from scratch.
then we have greedy algorithms that will make the choice that is most beneficial in the short term without considering the problem as a whole.
one example of this is dijkstra's shortest path algorithm.
on the flip side, we have backtracking algorithms, which take a more incremental approach by looking at all of the possible options, like a rat in a maze, exploring all the different potential paths.
now, when it comes to implementing your code, there are always multiple ways to get the job done.
one programming paradigm is declarative, where your code describes what the program does and the outcome, but doesn't care about things like control flow.
this style of programming is often associated with functional languages like haskell.
the other paradigm is imperative programming, where your code uses statements like if and while providing explicit instructions about how to prod an outcome.
it's associated with procedural languages like c.
today, most general purpose languages like python, javascript, kotlin, swift, and so on are multiparadigm, which means they support all these options at the same time.
in addition to object oriented programming, the idea behind oop is that you use classes to write a blueprint for the data or objects in your code.
a class can encapsulate variables, which are commonly called properties, as well as functions, which are usually called methods.
in this context, it's a common way to organize and reuse code because classes can share behaviors between each other through inheritance.
inheritance, where a subclass can extend and override the behaviors of the parent class.
and it opens the door to all kinds of other ideas called design patterns.
now, a class by itself doesn't actually do anything.
instead, it's used to instantiate objects, which are actual chunks of data that live in your computer's memory.
often you'll want to reference the same object over and over again in your code.
when data is long lived, it can't go in the call stack.
instead, most languages have a separate area of memory called the heap, which, unlike the call stack, can grow and shrink based on how your application is used.
it also allows you to pass objects by reference, which means you can use the same object in multiple variables without increasing the memory footprint because it always points to the same chunk of memory in the heap.
now, what's interesting is that if we go back to the cpu that we talked about in the beginning, you'll notice that it contains multiple threads.
a thread takes the physical cpu core and breaks it into virtual cores that allow it to run code simultaneously.
there are some programming languages that support parallelism, where you can write code that literally executes on two different threads at the same time.
however, many languages out there are only single threaded, but that doesn't mean they can't do two things at the same time time.
instead, they implement concurrency models like an event loop or coroutines that can pause or delay the normal execution of code to handle multiple jobs on a single thread at the same time.
now, in modern computing, we're rarely working with the bare metal cpu in ram.
instead, we work in the cloud with a virtual machine, which is just a piece of software that simulates hardware that allows us to take really big computers and split them up into a bunch of smaller virtual computers.
these machines are the backbone of the internet and are connected via the internet protocol.
each machine has a unique ip address to identify it on the network.
that ip address is usually aliased to a url that is registered in a global database called the domain name service.
now, to establish a connection, the two computers will perform a tcp handshake, which will allow them to exchange messages, called packets.
on top of that, there's usually a security layer like ssl to encrypt and decrypt the messages over the network.
now, the two computers can securely share data with the hypertext transfer protocol.
the client may request a webpage, then the server will respond with some html.
modern servers provide a standardized way for a client to request data, which is called an application programming interface, or api.
the most common architecture is rest, where urls are mapped to different data entities available on the server.
and that brings us to our final mother effin printers.
you're gonna need to learn how these things work inside and out, because every time you go to grandma's house, she's going to ask you to fix it, which shouldn't be a problem for a computer scientist like you.
thanks for watching and i will see you in the next one.